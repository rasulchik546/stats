<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Статистический трекер — K/A/D/W/L/ROUNDS — Enhanced + Ranks — GitHub sync</title>
<style>
  :root{
    --bg:#0b0b0b; --panel:#0f1113; --text:#e9eef8; --muted:#9aa3b2; --accent:#6ee7b7; --glass: rgba(255,255,255,0.03);
    --card-shadow: 0 6px 18px rgba(0,0,0,0.45);
    --radius:12px;
  }
  [data-theme="light"]{ --bg:#f6f8fa; --panel:#ffffff; --text:#0b1220; --muted:#556270; --accent:#0f766e; --glass: rgba(10,10,10,0.03); }
  *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#07080a);color:var(--text);-webkit-font-smoothing:antialiased}
  .wrap{max-width:1200px;margin:18px auto;padding:16px;display:grid;grid-template-columns:320px 1fr 320px;gap:14px}
  header{grid-column:1/-1;display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
  h1{font-size:18px;margin:0;color:var(--accent)}
  .card{background:linear-gradient(180deg,var(--panel),rgba(255,255,255,0.01));padding:14px;border-radius:var(--radius);box-shadow:var(--card-shadow);border:1px solid rgba(255,255,255,0.03)}
  label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
  input[type="text"],input[type="number"],select{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text);font-size:14px}
  .players{display:flex;flex-direction:column;gap:8px;max-height:64vh;overflow:auto;margin-top:10px}
  .player-row{display:flex;justify-content:space-between;align-items:center;padding:10px;border-radius:10px}
  .player-row:hover{background:var(--glass)}
  .player-row.selected{outline:2px solid rgba(255,255,255,0.04);background:linear-gradient(90deg, rgba(255,255,255,0.02), transparent)}
  .stat-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-top:10px}
  .stat{background:rgba(255,255,255,0.01);padding:12px;border-radius:10px;text-align:center}
  .ops{display:flex;gap:6px;justify-content:center;margin-top:8px}
  .hotbar{display:flex;justify-content:space-between;align-items:center;padding:10px;margin-top:10px;border-radius:8px;background:rgba(255,255,255,0.01)}
  button{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text);cursor:pointer}
  .small{font-size:13px;color:var(--muted)}
  footer{grid-column:1/-1;text-align:center;color:var(--muted);margin-top:10px;font-size:13px}
  .controls{display:flex;gap:8px;align-items:center}
  .search{display:flex;gap:8px;margin-top:10px}
  .flex{display:flex;gap:8px}
  .leader{display:flex;flex-direction:column;gap:8px;margin-top:10px}
  canvas.spark{width:100%;height:40px;border-radius:6px;display:block}
  .muted-pill{padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.02);font-size:12px;color:var(--muted)}
  .badge{padding:4px 8px;border-radius:999px;background:rgba(255,255,255,0.03);font-size:12px}
  .rank-silver{background:linear-gradient(90deg,#c0c0c0,#b0b0b0);color:#111}
  .rank-gold{background:linear-gradient(90deg,#ffd27f,#f6c85f);color:#111}
  .rank-platinum{background:linear-gradient(90deg,#cfeaf5,#9ad3e8);color:#111}
  .rank-diamond{background:linear-gradient(90deg,#b7e0ff,#8fcfff);color:#011}
  .rank-emerald{background:linear-gradient(90deg,#7bf0b3,#4edc93);color:#012}
  .rank-global{background:linear-gradient(90deg,#ffd3ff,#ffb7f0);color:#111}
  .sync-status{font-size:12px;color:var(--muted);margin-left:8px}
  @media (max-width:1100px){.wrap{grid-template-columns:1fr 360px;max-width:980px} aside:last-child{order:3} }
  @media (max-width:800px){.wrap{grid-template-columns:1fr;padding:12px} header{flex-direction:column;align-items:flex-start;gap:8px} .players{max-height:36vh} .stat-grid{grid-template-columns:repeat(2,1fr)} }
</style>
</head>
<body data-theme="dark">
  <div class="wrap">
    <header>
      <div style="display:flex;align-items:center;gap:12px">
        <div>
          <h1>Трекер игроков — K/A/D / MATCH W/L / ROUNDS</h1>
          <div class="small">Локально → localStorage • Ранги и номинации</div>
        </div>
        <div style="display:flex;flex-direction:column;gap:4px">
          <div class="small">GitHub sync: 
            <span id="ghConfigLabel" class="small" style="margin-left:6px;color:var(--muted)">not configured</span>
            <span id="syncState" class="sync-status"></span>
          </div>
        </div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <div class="controls">
          <button id="themeToggle">Тема</button>
          <button id="exportBtn">Экспорт</button>
          <button id="importBtn">Импорт</button>
          <!-- admin login buttons will be injected by admin panel script -->
        </div>
      </div>
    </header>

    <!-- LEFT: форма + список -->
    <aside class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>Создать игрока</strong>
        <div class="small" id="count">0</div>
      </div>

      <div style="margin-top:8px">
        <label>Имя</label>
        <input id="name" type="text" placeholder="Никнейм">
      </div>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px">
        <div>
          <label>KILLS</label>
          <input id="kills" type="number" min="0" value="0">
        </div>
        <div>
          <label>ASSISTS</label>
          <input id="assists" type="number" min="0" value="0">
        </div>
        <div>
          <label>DEATHS</label>
          <input id="deaths" type="number" min="0" value="0">
        </div>
        <div>
          <label>ROUNDS (кол-во раундов)</label>
          <input id="rounds" type="number" min="0" value="0">
        </div>
        <div>
          <label>WINS (MATCH WINS — победы в матчах)</label>
          <input id="wins" type="number" min="0" value="0">
        </div>
        <div>
          <label>LOSES (MATCH LOSES — поражения в матчах)</label>
          <input id="loses" type="number" min="0" value="0">
        </div>
      </div>

      <div style="display:flex;gap:8px;margin-top:10px">
        <button id="addBtn">Добавить</button>
        <button id="addZeroBtn">Добавить (с 0)</button>
        <button id="clearForm">Сброс</button>
      </div>

      <hr style="margin:10px 0;border:none;height:8px">

      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>Поиск / Сорт</strong>
        <div class="small">клики: открыть / дублировать</div>
      </div>

      <div class="search">
        <input id="searchInput" type="text" placeholder="Поиск по имени...">
        <select id="sortSelect" title="Сортировать">
          <option value="created">Сначала новые</option>
          <option value="rating">По рейтингу</option>
          <option value="kills">По киллам</option>
          <option value="wins">По победам</option>
        </select>
      </div>

      <div class="players" id="playersList"></div>

      <div class="leader card" style="margin-top:10px">
        <div class="small">Топ 3 (по рейтингу)</div>
        <div id="topList" style="display:flex;gap:8px"></div>
      </div>

      <div class="card" style="margin-top:10px">
        <div class="small"><strong>Номинации (кто что уничтжал)</strong></div>
        <div id="nominationsList" style="margin-top:8px;display:flex;flex-direction:column;gap:6px"></div>
      </div>
    </aside>

    <!-- CENTER: детали выбранного -->
    <main class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
        <div>
          <div id="selName" style="font-weight:700">Нет выбранного игрока</div>
          <div id="selInfo" class="small">Выберите игрока слева</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <div id="selRank" class="badge" style="display:none"></div>
          <button id="resetPlayer">Сбросить счётчики</button>
          <button id="deletePlayer" style="color:#ff7b7b">Удалить</button>
        </div>
      </div>

      <div class="stat-grid" id="statGrid">
        <div class="stat">
          <div class="small">KILLS</div><div id="vKills" style="font-weight:700">—</div>
          <div class="ops">
            <button data-op="k+">+1</button><button data-op="k-">-1</button><button id="editKills">Изм.</button>
          </div>
        </div>
        <div class="stat">
          <div class="small">ASSISTS</div><div id="vAssists" style="font-weight:700">—</div>
          <div class="ops">
            <button data-op="a+">+1</button><button data-op="a-">-1</button><button id="editAssists">Изм.</button>
          </div>
        </div>
        <div class="stat">
          <div class="small">DEATHS</div><div id="vDeaths" style="font-weight:700">—</div>
          <div class="ops">
            <button data-op="d+">+1</button><button data-op="d-">-1</button><button id="editDeaths">Изм.</button>
          </div>
        </div>
        <div class="stat">
          <div class="small">ROUNDS</div><div id="vRounds" style="font-weight:700">—</div>
          <div class="ops">
            <button data-op="r+">+1</button><button data-op="r-">-1</button><button id="editRounds">Изм.</button>
          </div>
        </div>
        <div class="stat">
          <div class="small">WINS (MATCH)</div><div id="vWins" style="font-weight:700">—</div>
          <div class="ops">
            <button data-op="w+">+1</button><button data-op="w-">-1</button><button id="editWins">Изм.</button>
          </div>
        </div>
        <div class="stat">
          <div class="small">LOSES (MATCH)</div><div id="vLoses" style="font-weight:700">—</div>
          <div class="ops">
            <button data-op="l+">+1</button><button data-op="l-">-1</button><button id="editLoses">Изм.</button>
          </div>
        </div>
      </div>

      <div style="display:flex;gap:10px;margin-top:12px;flex-wrap:wrap">
        <div class="card" style="flex:1;min-width:220px">
          <div class="small">KD = KILLS / DEATHS</div>
          <div id="vKD" style="font-weight:700;margin-top:6px">—</div>
          <div class="small" style="margin-top:6px">Если DEATHS = 0 → отображаем "Perfect" и в расчёте используем DEATHS_FOR_CALC = 1.</div>
        </div>
        <div class="card" style="flex:1;min-width:220px">
          <div class="small">KAD = (KILLS + ASSISTS) / DEATHS</div>
          <div id="vKAD" style="font-weight:700;margin-top:6px">—</div>
        </div>
        <div class="card" style="flex:1;min-width:220px">
          <div class="small">AVG = KILLS / ROUNDS (убийства за раунд)</div>
          <div id="vAVG" style="font-weight:700;margin-top:6px">—</div>
        </div>
        <div class="card" style="flex:1;min-width:220px">
          <div class="small">SVR = (ROUNDS − DEATHS) / ROUNDS × 100% (выживаемость)</div>
          <div id="vSVR" style="font-weight:700;margin-top:6px">—</div>
        </div>
        <div class="card" style="flex:1;min-width:220px">
          <div class="small">WINRATE = WINS / (WINS + LOSES) × 100% (матч-вдох)</div>
          <div id="vWINRATE" style="font-weight:700;margin-top:6px">—</div>
        </div>
        <div class="card" style="flex:1 1 100%;min-width:220px">
          <div class="small">RATING — комбинированный индекс (0–100)</div>
          <div id="vRATING" style="font-weight:700;margin-top:6px">—</div>
          <div class="small" style="margin-top:6px">Нормализация: KD cap 5, KAD cap 7, AVG cap 2, SVR 0–100, WINRATE 0–100.</div>
        </div>
      </div>

      <div class="hotbar" style="margin-top:12px">
        <div class="small">Hotbar: +1/−1 — быстрые изменения; "Изм." — прямое значение; всё сохраняется автоматически.</div>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="addMatchBtn">Добавить матч</button>
          <div class="muted-pill" id="matchCount">Матчей: 0</div>
        </div>
      </div>

      <div id="historyCard" class="card" style="margin-top:12px;display:none">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small">История матчей (последние 12)</div>
          <div class="small"><button id="clearHistory">Очистить историю</button></div>
        </div>
        <canvas id="spark" class="spark"></canvas>
        <div id="historyList" style="margin-top:8px;display:flex;flex-direction:column;gap:6px;max-height:160px;overflow:auto"></div>
      </div>

    </main>

    <!-- RIGHT: веса и пояснения -->
    <aside class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>Параметры рейтинга</strong>
        <button id="resetWeights">Сброс</button>
      </div>

      <div style="margin-top:10px">
        <label>Вес KD</label>
        <input id="wKD" type="range" min="0" max="100" value="30">
      </div>
      <div style="margin-top:10px">
        <label>Вес KAD</label>
        <input id="wKAD" type="range" min="0" max="100" value="25">
      </div>
      <div style="margin-top:10px">
        <label>Вес AVG</label>
        <input id="wAVG" type="range" min="0" max="100" value="20">
      </div>
      <div style="margin-top:10px">
        <label>Вес SVR</label>
        <input id="wSVR" type="range" min="0" max="100" value="10">
      </div>
      <div style="margin-top:10px">
        <label>Вес WINRATE</label>
        <input id="wWIN" type="range" min="0" max="100" value="15">
      </div>

      <hr style="margin:10px 0;border:none;height:8px">

      <div class="small">
        <strong>Формулы (точно реализовано в коде):</strong>
        <ol>
          <li><b>K D</b> = KILLS / DEATHS. Если DEATHS = 0 → отображаем "Perfect" и для расчёта берём DEATHS_FOR_CALC = 1.</li>
          <li><b>K A D</b> = (KILLS + ASSISTS) / DEATHS (DEATHS_FOR_CALC = 1 при DEATHS = 0).</li>
          <li><b>AVG</b> = KILLS / ROUNDS (если ROUNDS = 0 → AVG = 0).</li>
          <li><b>SVR</b> = (ROUNDS − DEATHS) / ROUNDS × 100% (если ROUNDS = 0 → SVR = 0%).</li>
          <li><b>WINRATE</b> = WINS / (WINS + LOSES) × 100% (если WINS+LOSES = 0 → WINRATE = 0%).</li>
          <li><b>RATING</b> = взвешенная сумма нормализованных метрик × 100 (см. реализацию в коде).</li>
        </ol>
      </div>

      <hr style="margin:8px 0;border:none;height:8px">

      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <button id="exportAll">Экспорт JSON</button>
        <button id="importAll">Импорт JSON</button>
        <button id="clearAll" style="color:#ff7b7b">Очистить всё</button>
      </div>
    </aside>

    <footer>Готово: добавлены номинации и ранги. Ранги считают общий статистический профиль — не только победы.</footer>
  </div>

<script>
/* =========================
   Core app (unchanged logic)
   ========================= */
const STORE = 'player_stats_v3';
const STORE_WEIGHTS = 'player_weights_v3';
let players = [];
let selectedId = null;
let weights = { kd:30, kad:25, avg:20, svr:10, win:15 };
let uiState = { theme: (document.body.getAttribute('data-theme')||'dark') };

const $ = id => document.getElementById(id);
function uid(){ return 'p_' + Math.random().toString(36).slice(2,9); }

// NOTE: we will override save/load later to add GitHub sync behaviour
function save(){ localStorage.setItem(STORE, JSON.stringify(players)); localStorage.setItem(STORE_WEIGHTS, JSON.stringify(weights)); localStorage.setItem('ui_state', JSON.stringify(uiState)); renderList(); renderSelected(); renderNominations(); }
function load(){ try{ const r = localStorage.getItem(STORE); const w = localStorage.getItem(STORE_WEIGHTS); const u = localStorage.getItem('ui_state'); players = r ? JSON.parse(r) : []; weights = w ? JSON.parse(w) : weights; if(u){ uiState = JSON.parse(u); document.body.setAttribute('data-theme', uiState.theme); } }catch(e){ console.error(e); players = []; } }

function computeKD(p){
  const denom = p.deaths === 0 ? 1 : p.deaths;
  const value = denom === 0 ? 0 : p.kills / denom;
  const display = p.deaths === 0 ? 'Perfect' : value.toFixed(2);
  return { display, value };
}
function computeKAD(p){
  const denom = p.deaths === 0 ? 1 : p.deaths;
  const value = denom === 0 ? 0 : (p.kills + p.assists) / denom;
  return { display: value.toFixed(2), value };
}
function computeAVG(p){
  if(!p.rounds) return { display: '0.00', value: 0 };
  const value = p.kills / p.rounds;
  return { display: value.toFixed(2), value };
}
function computeSVR(p){
  if(!p.rounds) return { display: '0.0%', value: 0 };
  const surv = Math.max(0, p.rounds - p.deaths);
  const value = (surv / p.rounds) * 100;
  return { display: value.toFixed(1) + '%', value };
}
function computeWINRATE(p){
  const totalMatches = (p.wins || 0) + (p.loses || 0);
  if(totalMatches === 0) return { display: '0.0%', value: 0 };
  const value = p.wins / totalMatches;
  return { display: (value*100).toFixed(1) + '%', value };
}
function computeRATING(p){
  const kd = computeKD(p).value;
  const kad = computeKAD(p).value;
  const avg = computeAVG(p).value;
  const svr = computeSVR(p).value;
  const win = computeWINRATE(p).value;

  const kd_norm = Math.min(kd, 5) / 5;
  const kad_norm = Math.min(kad, 7) / 7;
  const avg_norm = Math.min(avg, 2) / 2;
  const svr_norm = Math.min(Math.max(svr, 0), 100) / 100;
  const win_norm = Math.min(Math.max(win, 0), 1);

  const sumW = (weights.kd + weights.kad + weights.avg + weights.svr + weights.win) || 1;
  const score = (weights.kd*kd_norm + weights.kad*kad_norm + weights.avg*avg_norm + weights.svr*svr_norm + weights.win*win_norm) / sumW;
  const finalRating = score * 2;
  return { display: finalRating.toFixed(2), value: finalRating };
}

/* Ranks & nominations (unchanged) */
function computeRankScore(p){
  const kd_norm = Math.min(computeKD(p).value, 5) / 5;
  const kad_norm = Math.min(computeKAD(p).value, 7) / 7;
  const avg_norm = Math.min(computeAVG(p).value, 2) / 2;
  const svr_norm = Math.min(Math.max(computeSVR(p).value, 0), 100) / 100;
  const sumW = (weights.kd + weights.kad + weights.avg + weights.svr) || 1;
  const score = (weights.kd*kd_norm + weights.kad*kad_norm + weights.avg*avg_norm + weights.svr*svr_norm) / sumW;
  return Math.round(score * 100);
}
function computeRank(p){
  const s = computeRankScore(p);
  if(s >= 90) return { id: 'global', name: 'Global', cls: 'rank-global' };
  if(s >= 75) return { id: 'emerald', name: 'Emerald', cls: 'rank-emerald' };
  if(s >= 55) return { id: 'diamond', name: 'Diamond', cls: 'rank-diamond' };
  if(s >= 35) return { id: 'platinum', name: 'Platinum', cls: 'rank-platinum' };
  if(s >= 20) return { id: 'gold', name: 'Gold', cls: 'rank-gold' };
  return { id: 'silver', name: 'Silver', cls: 'rank-silver' };
}

function computeNominations(players){
  const res = {};
  if(!players.length) return res;
  let maxKills = -1, pidKills = null;
  let bestKD = -1, pidKD = null;
  let bestAVG = -1, pidAVG = null;
  let bestSingle = -1, pidSingle = null;
  let bestCons = Infinity, pidCons = null;
  let bestClutch = -1, pidClutch = null;

  players.forEach(p =>{
    if((p.kills||0) > maxKills){ maxKills = p.kills; pidKills = p.id; }
    const kd = computeKD(p).value; if(kd > bestKD){ bestKD = kd; pidKD = p.id; }
    const avg = computeAVG(p).value; if(avg > bestAVG){ bestAVG = avg; pidAVG = p.id; }
    const matches = p.matches || [];
    matches.forEach(m=>{ if(m.k > bestSingle){ bestSingle = m.k; pidSingle = p.id; } });
    if(matches.length >= 3){
      const arr = matches.map(m=>m.k);
      const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
      const variance = arr.reduce((a,b)=>a + Math.pow(b-mean,2),0)/arr.length;
      const std = Math.sqrt(variance);
      if(std < bestCons){ bestCons = std; pidCons = p.id; }
    }
    const clutchCount = (matches||[]).filter(m=>m.k >= 10 && m.win).length;
    if(clutchCount > bestClutch){ bestClutch = clutchCount; pidClutch = p.id; }
  });

  res['Top Kills (all-time)'] = pidKills;
  res['Best KD (all-time)'] = pidKD;
  res['Best AVG (kills/round)'] = pidAVG;
  res['Best Single-Match Kills'] = pidSingle;
  if(pidCons) res['Most Consistent (σ low)'] = pidCons;
  res['Clutch King (10+ kills wins)'] = pidClutch;
  return res;
}

/* Rendering */
const playersList = $('playersList');
const countEl = $('count');

function renderList(){
  playersList.innerHTML = '';
  const q = $('searchInput').value.trim().toLowerCase();
  const sort = $('sortSelect').value;
  let filtered = players.filter(p => !q || p.name.toLowerCase().includes(q));
  if(sort === 'rating') filtered.sort((a,b)=> computeRATING(b).value - computeRATING(a).value);
  else if(sort === 'kills') filtered.sort((a,b)=> b.kills - a.kills);
  else if(sort === 'wins') filtered.sort((a,b)=> b.wins - a.wins);
  else filtered.sort((a,b)=> b.createdAt - a.createdAt);

  countEl.textContent = players.length;
  filtered.forEach(p=>{
    const rank = computeRank(p);
    const div = document.createElement('div');
    div.className = 'player-row' + (p.id === selectedId ? ' selected' : '');
    div.innerHTML = `
      <div style="min-width:0">
        <div style="display:flex;gap:8px;align-items:center">
          <div style="font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${escapeHtml(p.name)}</div>
          <div class="badge ${rank.cls}" title="Ранг: ${rank.name}">${rank.name}</div>
        </div>
        <div class="small">K:${p.kills} A:${p.assists} D:${p.deaths} R:${p.rounds}</div>
        <div style="margin-top:6px"><small class="small">${p.matches && p.matches.length ? p.matches.length + ' матч(ов) • ' : ''}Создан: ${new Date(p.createdAt).toLocaleDateString()}</small></div>
      </div>
      <div style="display:flex;align-items:center;gap:8px">
        <div class="small" title="Рейтинг">${computeRATING(p).display}</div>
        <div style="display:flex;flex-direction:column;gap:6px">
          <button data-id="${p.id}" data-act="open">Открыть</button>
          <button data-id="${p.id}" data-act="dup">Дубл</button>
        </div>
      </div>
    `;
    playersList.appendChild(div);
  });

  renderTop3();
  renderNominations();
}

function renderTop3(){
  const top = [...players].sort((a,b)=> computeRATING(b).value - computeRATING(a).value).slice(0,3);
  const topList = $('topList'); topList.innerHTML = '';
  top.forEach((p,i)=>{
    const el = document.createElement('div'); el.className='card'; el.style.padding='8px'; el.style.flex='1';
    const rank = computeRank(p);
    el.innerHTML = `<div style="font-weight:700">#${i+1} ${escapeHtml(p.name)} <span class="badge ${rank.cls}" style="margin-left:8px">${rank.name}</span></div><div class="small">R:${computeRATING(p).display} • K:${p.kills} W:${p.wins}</div>`;
    topList.appendChild(el);
  });
}

function renderNominations(){
  const list = $('nominationsList'); list.innerHTML = '';
  const nom = computeNominations(players);
  for(const title in nom){
    const pid = nom[title];
    const el = document.createElement('div'); el.style.display='flex'; el.style.justifyContent='space-between'; el.style.alignItems='center'; el.style.padding='6px'; el.style.borderRadius='6px'; el.style.background='rgba(255,255,255,0.01)';
    el.innerHTML = `<div class="small">${escapeHtml(title)}</div><div class="small">${pid ? escapeHtml((players.find(p=>p.id===pid)||{name:'?'}).name) : '—'}</div>`;
    list.appendChild(el);
  }
}

/* Selection */
function selectPlayer(id){ selectedId = id; renderList(); renderSelected(); }
function find(id){ return players.find(x=>x.id===id); }
function renderSelected(){
  const nameEl = $('selName'), infoEl = $('selInfo');
  if(!selectedId){ nameEl.textContent = 'Нет выбранного игрока'; infoEl.textContent = 'Выбери слева'; updateStatFieldsEmpty(); return; }
  const p = find(selectedId);
  if(!p){ selectedId = null; renderSelected(); return; }

  nameEl.textContent = p.name;
  infoEl.textContent = 'Создан: ' + new Date(p.createdAt).toLocaleString();

  const rank = computeRank(p);
  const selRank = $('selRank'); selRank.style.display='inline-block'; selRank.className = 'badge ' + rank.cls; selRank.textContent = rank.name;

  $('vKills').textContent = p.kills;
  $('vAssists').textContent = p.assists;
  $('vDeaths').textContent = p.deaths;
  $('vRounds').textContent = p.rounds;
  $('vWins').textContent = p.wins;
  $('vLoses').textContent = p.loses;

  $('vKD').textContent = computeKD(p).display;
  $('vKAD').textContent = computeKAD(p).display;
  $('vAVG').textContent = computeAVG(p).display;
  $('vSVR').textContent = computeSVR(p).display;
  $('vWINRATE').textContent = computeWINRATE(p).display;
  $('vRATING').textContent = computeRATING(p).display;

  const matches = p.matches || [];
  $('matchCount').textContent = 'Матчей: ' + matches.length;
  if(matches.length){
    $('historyCard').style.display = 'block';
    renderHistory(p);
  } else {
    $('historyCard').style.display = 'none';
  }
}
function updateStatFieldsEmpty(){ ['vKills','vAssists','vDeaths','vRounds','vWins','vLoses','vKD','vKAD','vAVG','vSVR','vWINRATE','vRATING'].forEach(id=>$(id).textContent='—'); $('selRank').style.display='none'; }

/* Create / modify */
$('addBtn').onclick = ()=>{
  const name = $('name').value.trim();
  if(!name) return alert('Введите имя');
  const p = {
    id: uid(),
    name,
    kills: Math.max(0, Number($('kills').value) || 0),
    assists: Math.max(0, Number($('assists').value) || 0),
    deaths: Math.max(0, Number($('deaths').value) || 0),
    rounds: Math.max(0, Number($('rounds').value) || 0),
    wins: Math.max(0, Number($('wins').value) || 0),
    loses: Math.max(0, Number($('loses').value) || 0),
    matches: [],
    createdAt: Date.now()
  };
  players.unshift(p);
  selectedId = p.id;
  save();
  // reset
  $('name').value=''; $('kills').value=0; $('assists').value=0; $('deaths').value=0; $('rounds').value=0; $('wins').value=0; $('loses').value=0;
};
$('addZeroBtn').onclick = ()=>{ const name = $('name').value.trim(); if(!name) return alert('Введите имя'); const p = { id:uid(), name, kills:0, assists:0, deaths:0, rounds:0, wins:0, loses:0, matches:[], createdAt:Date.now() }; players.unshift(p); selectedId=p.id; save(); $('name').value=''; };

/* list delegation */
playersList.addEventListener('click', e=>{
  const btn = e.target.closest('button'); if(!btn) return;
  const id = btn.dataset.id; const act = btn.dataset.act;
  if(act === 'open') selectPlayer(id);
  if(act === 'dup'){ const p = find(id); if(!p) return; const copy = Object.assign({}, p, { id: uid(), name: p.name + '_copy', createdAt: Date.now() }); players.unshift(copy); save(); }
});

/* +/- editing */
document.querySelectorAll('[data-op]').forEach(b=> b.addEventListener('click', ()=> applyOp(b.getAttribute('data-op')) ) );
function applyOp(op){
  if(!selectedId){ alert('Выбери игрока'); return; }
  const p = find(selectedId); if(!p) return;
  switch(op){
    case 'k+': p.kills++; break;
    case 'k-': p.kills = Math.max(0,p.kills-1); break;
    case 'a+': p.assists++; break;
    case 'a-': p.assists = Math.max(0,p.assists-1); break;
    case 'd+': p.deaths++; break;
    case 'd-': p.deaths = Math.max(0,p.deaths-1); break;
    case 'r+': p.rounds++; break;
    case 'r-': p.rounds = Math.max(0,p.rounds-1); break;
    case 'w+': p.wins++; break;
    case 'w-': p.wins = Math.max(0,p.wins-1); break;
    case 'l+': p.loses++; break;
    case 'l-': p.loses = Math.max(0,p.loses-1); break;
  }
  save();
}

/* direct edit */
['editKills','editAssists','editDeaths','editRounds','editWins','editLoses'].forEach(id=>{
  const el = $(id); if(!el) return;
  el.onclick = ()=>{
    if(!selectedId){ alert('Выбери игрока'); return; }
    const p = find(selectedId); if(!p) return;
    const map = { editKills:'kills', editAssists:'assists', editDeaths:'deaths', editRounds:'rounds', editWins:'wins', editLoses:'loses' };
    const field = map[id];
    const v = prompt('Новое значение для ' + field.toUpperCase(), p[field]);
    if(v === null) return;
    p[field] = Math.max(0, parseInt(v) || 0);
    save();
  };
});

/* delete / reset */
$('deletePlayer').onclick = ()=>{
  if(!selectedId) return alert('Нет выбранного');
  if(!confirm('Удалить игрока?')) return;
  players = players.filter(x=>x.id !== selectedId);
  selectedId = players.length ? players[0].id : null;
  save();
};
$('resetPlayer').onclick = ()=>{
  if(!selectedId) return alert('Нет выбранного');
  if(!confirm('Сбросить все счётчики у игрока?')) return;
  const p = find(selectedId); if(!p) return;
  p.kills = p.assists = p.deaths = p.rounds = p.wins = p.loses = 0;
  p.matches = [];
  save();
};

/* weights */
['wKD','wKAD','wAVG','wSVR','wWIN'].forEach(id=>{
  const el = $(id);
  if(!el) return;
  el.oninput = ()=>{
    weights.kd = Number($('wKD').value);
    weights.kad = Number($('wKAD').value);
    weights.avg = Number($('wAVG').value);
    weights.svr = Number($('wSVR').value);
    weights.win = Number($('wWIN').value);
    save();
  };
});
$('resetWeights').onclick = ()=>{ weights = { kd:30, kad:25, avg:20, svr:10, win:15 }; $('wKD').value=30; $('wKAD').value=25; $('wAVG').value=20; $('wSVR').value=10; $('wWIN').value=15; save(); };

/* export/import/clear */
$('exportBtn').onclick = ()=>{
  const data = { players, weights };
  const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'players_export.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
};
$('importBtn').onclick = ()=> $('importAll').click();
$('exportAll').onclick = $('exportBtn').onclick;
$('importAll').onclick = ()=>{
  const inp = document.createElement('input'); inp.type='file'; inp.accept='application/json';
  inp.onchange = async ()=>{ const f = inp.files[0]; if(!f) return; try{ const txt = await f.text(); const data = JSON.parse(txt); if(Array.isArray(data.players)) players = data.players; if(data.weights) weights = data.weights; selectedId = players.length ? players[0].id : null; save(); alert('Импорт завершён'); }catch(e){ alert('Ошибка импорта'); console.error(e); } };
  inp.click();
};
$('clearAll').onclick = ()=>{
  if(!confirm('Уничтожить все данные (лок locally)?')) return;
  players = []; selectedId = null; weights = { kd:30,kad:25,avg:20,svr:10,win:15 }; localStorage.removeItem(STORE); localStorage.removeItem(STORE_WEIGHTS); save();
};

/* theme */
$('themeToggle').onclick = ()=>{ const cur = document.body.getAttribute('data-theme') || 'dark'; const next = cur === 'dark' ? 'light' : 'dark'; document.body.setAttribute('data-theme', next); uiState.theme = next; save(); };

/* add match */
$('addMatchBtn').onclick = ()=>{
  if(!selectedId) return alert('Выбери игрока');
  const k = parseInt(prompt('KILLS в матче', '0')) || 0;
  const a = parseInt(prompt('ASSISTS в матче', '0')) || 0;
  const d = parseInt(prompt('DEATHS в матче', '0')) || 0;
  const r = parseInt(prompt('ROUNDS в матче', '0')) || 0;
  const win = confirm('Победа в матче? (OK = да, Отмена = нет)');
  const p = find(selectedId);
  if(!p) return;
  p.matches = p.matches || [];
  p.matches.push({ k,a,d,r,win: !!win, timestamp: Date.now() });
  p.kills += k; p.assists += a; p.deaths += d; p.rounds += r; if(win) p.wins++; else p.loses++;
  save();
};

$('clearHistory').onclick = ()=>{ if(!selectedId) return alert('Выбери игрока'); if(!confirm('Очистить историю матчей?')) return; const p=find(selectedId); if(!p) return; p.matches=[]; save(); };

function renderHistory(p){
  const list = $('historyList'); list.innerHTML='';
  const arr = (p.matches||[]).slice(-12).reverse();
  arr.forEach(m=>{
    const el = document.createElement('div'); el.className='small'; el.style.display='flex'; el.style.justifyContent='space-between'; el.style.alignItems='center'; el.style.padding='6px'; el.style.borderRadius='6px'; el.style.background='rgba(255,255,255,0.01)';
    el.innerHTML = `<div>K:${m.k} A:${m.a} D:${m.d} R:${m.r}</div><div>${m.win? 'W':'L'} • ${new Date(m.timestamp).toLocaleString()}</div>`;
    list.appendChild(el);
  });
  drawSpark(p.matches||[]);
}

function drawSpark(matches){
  const canvas = $('spark'); if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const data = (matches||[]).slice(-24).map(m=>m.k);
  const w = canvas.clientWidth; const h = canvas.clientHeight;
  canvas.width = Math.round(w*devicePixelRatio); canvas.height = Math.round(h*devicePixelRatio);
  ctx.scale(devicePixelRatio, devicePixelRatio);
  ctx.clearRect(0,0,w,h);
  if(!data.length) return;
  const max = Math.max(...data); const min = Math.min(...data);
  const span = Math.max(1, max - min);
  ctx.lineWidth = 2; ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--accent') || '#6ee7b7';
  ctx.beginPath();
  data.forEach((v,i)=>{
    const x = (i/(data.length-1 || 1))*(w-8)+4;
    const y = h - ((v - min) / span) * (h-8) - 4;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();
}

function escapeHtml(s){ return String(s).replace(/[&<>"]+/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m]||m)); }

$('searchInput').oninput = renderList; $('sortSelect').onchange = renderList;

/* Initial local load/render */
load();
if(players.length && !selectedId) selectedId = players[0].id;
renderList();
renderSelected();
window.addEventListener('resize', ()=>{ if(selectedId){ const p=find(selectedId); if(p && p.matches && p.matches.length) drawSpark(p.matches); } });

/* =========================
   GitHub-sync helpers (single-file solution)
   - stores repo config in localStorage under 'gh_sync_config_v1'
   - stores PAT in sessionStorage under 'gh_token_v1' (session only)
   - admin flow prompts for local password '5ugaradmin', then asks for PAT & repo config
   ========================= */

/*
  Usage flow:
  - Open page on device A. Click "Войти как админ" (admin panel button).
  - Enter local password: 5ugaradmin
  - When prompted, enter GitHub Personal Access Token (PAT) that has repo permissions.
  - Enter repo owner/name/branch/path (e.g. owner: youruser, repo: myrepo, branch: main, path: data/players.json)
  - After that, any save() will attempt to push the updated players array into the specified file.
  - On device B (non-admin), load() will try to fetch raw file from GitHub if config exists, otherwise uses localStorage.
*/

// keys
const GH_CONFIG_KEY = 'gh_sync_config_v1';
const GH_TOKEN_KEY = 'gh_token_v1'; // stored in sessionStorage

function getGhConfig(){
  try{ const s = localStorage.getItem(GH_CONFIG_KEY); return s ? JSON.parse(s) : null; }catch(e){ return null; }
}
function setGhConfig(cfg){
  localStorage.setItem(GH_CONFIG_KEY, JSON.stringify(cfg));
  updateGhLabel();
}
function clearGhToken(){ sessionStorage.removeItem(GH_TOKEN_KEY); updateGhLabel(); }
function setGhToken(token){ sessionStorage.setItem(GH_TOKEN_KEY, token); updateGhLabel(); }
function getGhToken(){ return sessionStorage.getItem(GH_TOKEN_KEY); }

function updateGhLabel(){
  const cfg = getGhConfig();
  const token = getGhToken();
  const lbl = $('ghConfigLabel');
  const state = $('syncState');
  if(!cfg){ lbl.textContent = 'not configured'; state.textContent = ''; return; }
  lbl.textContent = `${cfg.owner}/${cfg.repo}/${cfg.branch}/${cfg.path}`;
  if(token) state.textContent = ' (admin: connected)';
  else state.textContent = ' (read-only)';
}

/* Fetch raw (public) */
async function fetchRawPlayers(cfg){
  if(!cfg) return null;
  const rawUrl = `https://raw.githubusercontent.com/${cfg.owner}/${cfg.repo}/${cfg.branch}/${cfg.path}`;
  try{
    const resp = await fetch(rawUrl, {cache: 'no-store'});
    if(!resp.ok) return null;
    const text = await resp.text();
    return JSON.parse(text);
  }catch(e){
    console.warn('fetchRawPlayers failed', e);
    return null;
  }
}

/* Fetch file metadata via GitHub API (to obtain sha) */
async function fetchFileMeta(cfg){
  if(!cfg) return null;
  const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${cfg.path}?ref=${cfg.branch}`;
  try{
    const resp = await fetch(apiUrl, { headers: { 'Accept':'application/vnd.github.v3+json' } });
    if(resp.status === 404) return null; // file not found
    if(!resp.ok) throw new Error('GitHub API fetchFileMeta failed: ' + resp.status);
    return await resp.json(); // contains .sha and .content
  }catch(e){
    console.warn('fetchFileMeta err', e);
    return null;
  }
}

/* Update or create file on GitHub using PAT */
async function pushPlayersToGitHub(cfg, token, playersArray, commitMessage = 'Update players via tracker'){
  if(!cfg) throw new Error('No GH config');
  const apiUrl = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${cfg.path}`;
  // get current meta to know if exists and obtain sha
  let current = await fetchFileMeta(cfg);
  const bodyObj = {
    message: commitMessage,
    content: b64EncodeUnicode(JSON.stringify(playersArray, null, 2)),
    branch: cfg.branch
  };
  if(current && current.sha) bodyObj.sha = current.sha;
  // PUT with auth
  try{
    const resp = await fetch(apiUrl, {
      method: 'PUT',
      headers: {
        'Accept':'application/vnd.github.v3+json',
        'Authorization': 'token ' + token,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(bodyObj)
    });
    const resJson = await resp.json();
    if(!resp.ok){
      console.warn('GitHub push error', resJson);
      throw new Error('GitHub push failed: ' + (resJson && resJson.message ? resJson.message : resp.status));
    }
    return resJson;
  }catch(e){
    console.error('pushPlayersToGitHub err', e);
    throw e;
  }
}

/* Helper: base64 encode unicode properly */
function b64EncodeUnicode(str) {
    // https://developer.mozilla.org/en-US/docs/Glossary/Base64
    return btoa(unescape(encodeURIComponent(str)));
}

/* ADMIN logic integrated with local admin panel: when admin logs in, prompt for PAT & repo config */
(function adminGitIntegration(){
  // We'll add handlers to admin login button (which admin panel script injects). If admin panel not injected, we still provide function.
  window.__gh_setConfig = setGhConfig;
  window.__gh_setToken = setGhToken;
  window.__gh_clearToken = clearGhToken;
  window.__gh_pushNow = async function(){
    const cfg = getGhConfig();
    const token = getGhToken();
    if(!cfg || !token) return alert('Нет конфигурации или токена GitHub. Зайдите как админ и настройте.');
    try{
      await pushPlayersToGitHub(cfg, token, players, 'Update players (web tracker)');
      alert('Push -> OK');
    }catch(e){
      alert('Ошибка при push: ' + e.message);
    }
  };

  // Hook admin panel button if it exists (the admin panel script below will create buttons with these IDs)
  document.addEventListener('DOMContentLoaded', ()=>{
    // If admin UI button exists, attach a flow: ask for local password, if correct ask for PAT & repo config
    document.addEventListener('click', async (e)=>{
      const btn = e.target.closest && e.target.closest('button');
      if(!btn) return;
      if(btn.id === 'adminLoginBtn'){ // admin clicked local login
        // Local password (as you asked)
        const pw = prompt('Введите локальный пароль админа: (5ugaradmin)', '');
        if(pw === null) return;
        if(pw !== '5ugaradmin'){ alert('Неверный пароль'); return; }
        // now ask for GitHub token (PAT)
        const token = prompt('Вставьте GitHub Personal Access Token (PAT) (repo/public_repo scope). Будет храниться в sessionStorage на время сессии.', '');
        if(token === null) return;
        if(!token.trim()){ alert('Токен пуст'); return; }
        setGhToken(token.trim());
        // ask for repo config if not already
        const existing = getGhConfig();
        let useExisting = false;
        if(existing){
          useExisting = confirm(`Использовать текущую конфигурацию репо?\n${existing.owner}/${existing.repo}/${existing.branch}/${existing.path}`);
        }
        if(!useExisting){
          const owner = prompt('GitHub owner (user or org)', existing ? existing.owner : '');
          if(owner === null) return;
          const repo = prompt('GitHub repo name', existing ? existing.repo : '');
          if(repo === null) return;
          const branch = prompt('Branch (обычно main)', existing ? existing.branch : 'main');
          if(branch === null) return;
          const path = prompt('Path to data file in repo (например data/players.json)', existing ? existing.path : 'data/players.json');
          if(path === null) return;
          const cfg = { owner: owner.trim(), repo: repo.trim(), branch: branch.trim(), path: path.trim() };
          setGhConfig(cfg);
        }
        updateGhLabel();
        // attempt to start realtime-ish: try fetch file and offer to pull into local
        const cfg2 = getGhConfig();
        try{
          const cloud = await fetchRawPlayers(cfg2);
          if(cloud && Array.isArray(cloud)){
            if(confirm('Загрузить данные из GitHub в локальное хранилище (переписать локальные данные)?')){
              players = cloud;
              selectedId = players.length ? players[0].id : null;
              save();
              alert('Данные загружены из GitHub');
            }
          } else {
            // if file not found, propose to create
            if(confirm('Файл не найден в репозитории. Создать новый файл (players = []) в репо сейчас?')){
              // push empty array right away
              try{
                await pushPlayersToGitHub(cfg2, token.trim(), players, 'Create players file (init)');
                alert('Файл создан в репозитории.');
              }catch(e){ alert('Не удалось создать файл: ' + e.message); }
            }
          }
        }catch(e){
          console.warn('After admin login cloud sync check failed', e);
          alert('Не удалось связаться с GitHub API: ' + (e.message || e));
        }
      }

      if(btn.id === 'adminLogoutBtn'){
        clearGhToken();
        alert('Admin: token cleared for this session. Local admin flag cleared.');
      }
    });
  });
})();

/* Finally: override original load/save to integrate GitHub (tries cloud read if config present; save pushes if admin token present) */
(function integrateSaveLoad(){
  const ORIGINAL_load = window.load && typeof window.load === 'function' ? window.load.bind(window) : null;
  const ORIGINAL_save = window.save && typeof window.save === 'function' ? window.save.bind(window) : null;

  window.load = async function(){
    if(ORIGINAL_load) try{ ORIGINAL_load(); }catch(e){ console.warn(e); }
    // Try cloud if config present
    const cfg = getGhConfig();
    if(cfg){
      try{
        const cloud = await fetchRawPlayers(cfg);
        if(cloud && Array.isArray(cloud)){
          players = cloud;
          selectedId = players.length ? players[0].id : null;
          renderList();
          renderSelected();
          console.log('Loaded players from GitHub (raw)');
        }
      }catch(e){ console.warn('cloud load failed', e); }
    }
  };

  window.save = async function(){
    if(ORIGINAL_save) try{ ORIGINAL_save(); }catch(e){ console.warn(e); }
    // attempt push if admin token exists
    const token = getGhToken();
    const cfg = getGhConfig();
    if(token && cfg){
      try{
        await pushPlayersToGitHub(cfg, token, players, 'Update players via web tracker');
        console.log('Pushed to GitHub');
      }catch(e){
        console.warn('push failed', e);
        alert('Не удалось сохранить в GitHub: ' + (e.message || e));
      }
    }
  };
})();

/* update label initially */
updateGhLabel();

/* =========================
   Simple admin panel (local password + integration hooks)
   - adds buttons in header: Войти как админ / Выйти
   - these buttons already wired above
   ========================= */
(function createAdminPanelUI(){
  const header = document.querySelector('header');
  if(!header) return;
  const target = header.querySelector('.controls') || header;
  const wrapper = document.createElement('div');
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'center';
  wrapper.style.gap = '8px';
  wrapper.innerHTML = `<div id="adminControls" style="display:flex;gap:8px;align-items:center">
    <div id="adminBadge" style="font-weight:700;display:none;color:#ffd27f">ADMIN</div>
    <button id="adminLoginBtn">Войти как админ</button>
    <button id="adminLogoutBtn" style="display:none">Выйти</button>
  </div>`;
  target.appendChild(wrapper);

  function isLocalAdmin(){ return localStorage.getItem('is_admin_v3') === '1'; }
  function setLocalAdmin(on){
    localStorage.setItem('is_admin_v3', on ? '1' : '0');
    update();
  }
  function update(){
    const badge = document.getElementById('adminBadge');
    const loginBtn = document.getElementById('adminLoginBtn');
    const logoutBtn = document.getElementById('adminLogoutBtn');
    if(isLocalAdmin()){ if(badge) badge.style.display='inline-block'; if(loginBtn) loginBtn.style.display='none'; if(logoutBtn) logoutBtn.style.display='inline-block'; }
    else { if(badge) badge.style.display='none'; if(loginBtn) loginBtn.style.display='inline-block'; if(logoutBtn) logoutBtn.style.display='none'; }
  }

  document.addEventListener('click', (e)=>{
    const btn = e.target.closest && e.target.closest('button');
    if(!btn) return;
    if(btn.id === 'adminLoginBtn'){
      const pw = prompt('Введите пароль администратора (локально)', '');
      if(pw === null) return;
      if(pw === '5ugaradmin'){
        setLocalAdmin(true);
        alert('Локальный админ включён — теперь введите GitHub PAT и конфиг (если нужно) через последующие prompts.');
        // Trigger click flow to prompt for token + config using GH integration code: emulate click to that same button handler used earlier
        // We rely on the other handler wired in adminGitIntegration's document click listener; just trigger it.
        // Simulate: call __gh_setToken? but we want interactive prompts — so just trigger a click on the same button to reuse that handler.
        // The handler that asks for token is bound to adminLoginBtn as well; we'll call it by dispatching another click.
        setTimeout(()=>{ document.getElementById('adminLoginBtn').dispatchEvent(new MouseEvent('click')); }, 50);
      } else {
        alert('Неверный пароль');
      }
    }
    if(btn.id === 'adminLogoutBtn'){
      setLocalAdmin(false);
      // also clear session token for safety
      sessionStorage.removeItem('gh_token_v1');
      updateGhLabel();
      alert('Локальный админ выключен; session token cleared.');
    }
  });

  update();
})();

</script>

</body>
</html>
